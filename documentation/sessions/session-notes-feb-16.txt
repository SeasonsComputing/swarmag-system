# SwarmAg System — Session Notes
**Mon Feb 16, 2026**

---

## 1. Refresh Repo

    I updated the repo just prior to session and again prior to posting this. Please rescan documentations and source.

---

## 2. Offline-First — NO!

    I don't want to see "offline-first" anywhere.
    It has meaning and it ain't what we do.
    I submit to you what we do is better.

    My point here, as always, is consistency is accuracy's best friend.
    And we have purposefully rejected offline-first.
    That while pretty on paper; in practice it introduces complexity not befitting the solution scope as we defined.

    We however kept the notion of providers we just scoped them to abstraction crud+busrule.
    And we reduced from an exhaustive provider library to a precise maker per abstraction.
    Which was also a brilliant reduction on our behalf. Shrunk the design, shrunk code volume, shrunk design scope...

    Arch-core talk about design principle and capabilities to inform arch-back and arch-ux
    So future work conforms to the design principle and capabilities will extend and evolve.

    For example, CRUD & BusRules of Jobs and IndexedDB capabilities is employed by the ops-mobile-app to support automated workflow progression with all its benefits like telemetry and GPS and knowledge capture absent a stable connection.

    So I'm thinking we make this a little more general in arch-core and focus on design principle:
    **Design Principle: Clients of CRUD and business rules for Abstractions with the provider of local rdbms capabilities.**
    **Capabilities: remote RDBMS via Supabase+Postgres, remote HTTP service via edge (Netlify or Supabase) or cloud (deno or node) , local RDBMS via IndexedDb, remote service via edge (Netlify or Supabase functions).**

---

## 3. architecture-domain: WorkflowStep Questions

    So the data-dictionary is wrong. It's missing WorkflowStep[].

    This is what I thought `name: Abstraction[]` was mapped to jsonb column-type.
    I presume then too `name: Abstraction` is also mapped to jsonb column-type.

    In the past I've made the rule that jsonb column's always contain 1 object and it contained the POJO or POJO array to simply the api surface. Is that useful in today's tech?

    The other pattern is `things: ID[]` but I don't see any of those in our domain.

    And every other association is 4NM, so I would see a FK ID or join-table.
    Should we declare the join-table in the domain doc so it's generated uniformly?
    Like Abstraction_m_Abstraction?

    So I think the issue is the domain.md solution space, abstractions and data-dictionary is out of sync with each other and the adapter code is out of sync with everything.

    For example, we talk about Tasks in the solution space. But it's absent from the domain model and in the data-dictionary and code as WorkflowStep. Services and Assets need better SSoT definitions so I incorporated the data-list into the domain. I want to surface Task but it's difficult because domain#2 is talking about relationship types not relationships between abstractions in our solution space. We need both I think while avoiding duplication.

    I've done other little fixes, like using `notes: Note[]` instead of `notes?` Asset had attachments, I changed it to notes. I replaced workflow -> service FK-binding for tag-binding. A Workflow declares tags that apply to it. Each service declares which workflow tags are recommended. However I imagine a UX where typing a set of tags filters the list of available workflows for a job assessment. Job assessments require multiple workflows, that's a m:m cardinality and it's missing. And finally I don't think we quite capture Workflows quite right.

    I think we're missing an essential abstraction, the Job Work. Job has a Job Assessment, Job Plan and Job Work.

    A Job Work entity is added to the Job when the works begins transitioning the Job state to 'inprogress'
    Job Work captures state about the overall job. Job.state == 'inprogress' is our lock state.
    Only Jobs in this state can be deepCloned for progressing the Job Plan Workflow, Tasks, and checklists

    I removed target locations from Job Plan.

    Would it be useful to have the root Job have a collection of Workflows that
    essentially define how to perform the assessment itself.
    The Job Log would then become the input to automate a draft of the Job Assessment.

    And finally the Job phase -> Workflow does not capture the needs I envision (at least not obviously).

---

## 4. architecture-core TODOs

    4.1.1 huh?

    I can think of examples where a ux package might imbue additional methods onto API or in the case testings replaces APIs with mock versions.

---

## 5. architecture-back

    Agreed, the examples and guidance should be to precreate local ID's.

### 5.2 Section 5.1 — Adapters vs. domain/adapter

    You miss my point. The adapters literally have attributes that no longer exist. Every dictionary return include a payload which is unnecessary.

### 5.3 Generate Adapters From Scratch

    This is to fix 5.2

---

## 6. Rewrite foundation/style-guide

    All the arch documents have sample code. There is an implicit naming convention, style, etc.
    There is also a tone if code that follows convention.
    You can rewrite from scratch or reconcile but what's there guarantees inconsistent code across coding sessions.

---

## 7. core/api

    I wanted you to see that I renamed files and added additional placeholders.

    I also now distinguish between makers of APIs and wraps of handlers.

    I also wanted you to see the layout of the files:
      NEW FILE HEADER
      IMPORTS
      PUBLIC EXPORTS
      PRIVATE IMPLEMENTATION

    I want all files in core-api to follow this style. The comments need to be filled in.

    I want to use User as a steal-thread or vertical slice to validate ux-api + core-api.
    From user-unit-test to remote user, local user, and subapbase business rule.

    Let's get this right, hten we'll generate the rest of api.

    Agreed we should encapsulate related api methods within a contract. However these should be in ux-api as core-api is general purpose.

    Auth specifically. There is a logon screen for ops and admin. And customer uses expiring access codes for passwordless. That code needs to live somewhere. I imagined AuthApiContract { logon..., logout, ...forgot password }

---

## 8. README & CONSTITUTION

README discussion on Config is wrong.

The CONSTITUTION is to enforce the 3RM for the swarmag system development model. It is intended primarily to keep the AI's honest and constrained and conforming. I yield to your judgment how to best capture that. Though I think your probably damn close already.

---

So we need to get README, domain, arch-core, arch-back and style-guide to the point we can create a prompt to regenerate the entire source/domain code and source/back/migations initial schema with seed data. I think this prompt should be good enough to be preserved in documentation/prompts so we can run it again.

We then need to get arch-ux to the point we can create a prompt to update core-ui including the file format complete file header content.

We then need to create a steal-thread of User client for supabase and indexeddb for unit testing.

We then need to flesh out any additional api contracts we need. And implement.

Then I need to start to wrap my ahead around the UX stack. To do this we are going to implement a shared login component and home page for admin & ops apps. The home page id a dashboard in both cases.

*End of session notes — edit inline and return for follow-up decisions.*
